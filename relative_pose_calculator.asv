[tvec, rmat] = calculateSCPose(200, 100, 100, 0, 0, 0, -15)
tvec = tvec.*0.001
rvec = rotmat2vec3d(rmat)
%% 
cs_rot = [.604 .788 .118;
    -.788 .613 -.052;
    -.114 -.062 .992];
cs_tvec = [.354; 1.625; -1.42];
tc_tvec = [-.01; -.38; 1.34];
cam_point = [-.023; -.341; 1.390];

res = cs_tvec + cs_rot*cam_point
r = sqrt(res(1)^2 + res(2)^2 + res(3)^2)
ang = rad2deg(atan(res(1)/res(3)))
%% 
sonar_pt = [ 7.48461077  3.56225735 12.44758855 11.64710826  5.96369822  4.92307384 ... 
    13.88845307  6.36393836 11.96730038  5.00312187 11.64710826 10.60648389 5.64350610;
   1.37769737  1.40698799  1.4765532   1.52048913  1.4541438   1.37202361  1.50391362  ...
    1.3745121   1.55119494  1.40686248  1.48898267  1.54372947 1.35460417];
cam_pt = [[-0.31181931 -0.4512467  -0.33766299 -0.46533855 -0.4888422  -0.35255207 ...
  -0.34627754 -0.33218569 -0.49431949 -0.43088032 -0.3870103  -0.51468587 -0.30320476]
 [ 0.03730469 -0.04969186  0.17623849  0.16548973  0.01299416 -0.02256834 ...
   0.22254976  0.00736817  0.18186448 -0.01975534  0.16267673  0.15192797 -0.00900658]
 [ 1.2066785   1.21230033  1.27275046  1.30680063  1.24994394  1.19386979 ...
   1.29477444  1.20027415  1.32242026  1.21870469  1.28196573  1.3160159 1.18465452]];
rot = [[-3.6732051e-06  1.0000000e+00  0.0000000e+00]
 [-1.0000000e+00 -3.6732051e-06 -0.0000000e+00]
 [-0.0000000e+00  0.0000000e+00  1.0000000e+00]];
tvec = [0.1544; -0.244; 0.1242];
sonar_frame = tvec + rot*cam_pt;
xx = sonar_frame(1,:);
yy = sonar_frame(2,:);
zz = sonar_frame(3,:);
range = sqrt(xx.*xx + yy.*yy + zz.*zz)
angle = rad2deg(atan2(xx, zz))
angle_err = (sonar_pt(1,:)-angle)/.4;
range_err = (sonar_pt(2,:)-range)/.0025;
intermed = sqrt(angle_err.*angle_err + range_err.*range_err)
err = sum(sqrt(angle_err.*angle_err + range_err.*range_err))
%% 

% Add sonar angle, sonar offsets
function [t, rot] = calculateSCPose(x, y, z, pitch1, pitch2, roll, yaw)
% Calculate translation and roation that maps sonar points into camera
% frame
%
% :return t: 3x1 translation vector
% :return rot: 3x3 rotation matrix
    pitch = pitch1+pitch2;
    phi = pitch*pi/180;
    gamma = yaw*pi/180;
    theta = roll*pi/180;
    rotX = [1 0 0; 
            0 cos(phi) -sin(phi);
            0 sin(phi) cos(phi)];
    rotY = [cos(gamma) 0 sin(gamma);
            0 1 0;
            -sin(gamma) 0 cos(gamma)];
    rotZ = [cos(theta) -sin(theta) 0;
            sin(theta) cos(theta) 0;
            0 0 1];
    rotXY = rotX*rotY;
    rot = rotXY*rotZ;

    xtotal = 45+x+55;
    ytotal = -(20+y+35);
    ztotal = 20+z+63+8; %TODO: add camera focal point offset
    offsetz = -42.8;  %offset from x-axis to O1
    cam_off = 52.8;
    offsetx = -(42.8);  %offset from y-axis to O2
    %camx = 52.8; camz = 63; camy = ; 
    sony = 29+18; sonz = -91.39+60+58.8;

    t = [xtotal; sony; -sonz] + rotX*[0; ytotal; offsetz] + rotXY*[offsetx; cam_off; ztotal];  %rot*[camx; 0; 0];
end

function [t, rot] = calculateCSPose(x, y, z, pitch1, pitch2, roll, yaw)
% Calculate translation and roation that maps camera points into sonar
% frame
%
% Coordinate system: x right, y down, z forward
% :return t: 3x1 translation vector
% :return rot: 3x3 rotation matrix
    pitch = pitch1+pitch2; %pitch up is positive
    phi = pitch*pi/180;
    gamma = yaw*pi/180;
    theta = roll*pi/180;
    rotX = [1 0 0; 
            0 cos(phi) -sin(phi);
            0 sin(phi) cos(phi)];
    rotY = [cos(gamma) 0 sin(gamma);
            0 1 0;
            -sin(gamma) 0 cos(gamma)];
    rotZ = [cos(theta) -sin(theta) 0;
            sin(theta) cos(theta) 0;
            0 0 1];
    rotZY = rotZ*rotY;
    rot = rotZY*rotX;

    xtotal = -(45+x+55);
    ytotal = 20+y+35;
    ztotal = -20-z-63-8; %TODO: add camera focal point offset
    offsetz = 42.8;  %offset from O1 to O2 in z direction
    offsetx = 42.8+52.8;  %offset from O to O1 in x direction
    %camx = 52.8; camz = 63; camy = ; 
    sony = -29-18; sonz = -91.39+60+58.8; %find real vals

    t = rotZ*[offsetx; 0; ztotal] + rotZY*[0; ytotal; offsetz] + rot*[xtotal; sony; sonz];  %rot*[camx; 0; 0]; 
    clf;
    figure(1);
    plot3([0, 0],[0,0],[0,-80], "b-", "LineWidth", 5)
    hold on;
    segment0 = rotZ*[0 52.8 52.8 offsetx;  0 0 0 0;  -71 -71 ztotal ztotal];
    plot3(segment0(1,:),segment0(2,:),segment0(3,:))
    segment1 = rotZY
    xlabel("x"); ylabel("y"); zlabel("z");
end